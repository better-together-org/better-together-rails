# This workflow uses actions that are not certified by GitHub.  They are
# provided by a third-party and are governed by separate terms of service,
# privacy policy, and support documentation.
#
# This workflow will install a prebuilt Ruby version, install dependencies, and
# run tests and linters.
name: "Ruby on Rails CI"
on: push
jobs:
  rspec:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgis/postgis:latest
        ports:
          - "5432:5432"
        env:
          POSTGRES_DB: rails_test
          POSTGRES_USER: rails
          POSTGRES_PASSWORD: password
      elasticsearch:
        image: elasticsearch:7.17.23
        ports:
          - "9200:9200"
        env:
          "node.name": elasticsearch
          "cluster.name": better-together-es
          "discovery.seed_hosts": elasticsearch
          "discovery.type": single-node
          "bootstrap.memory_lock": true
          "ES_JAVA_OPTS": "-Xms512m -Xmx512m"
    env:
      RAILS_ENV: test
      DATABASE_URL: "postgis://rails:password@localhost:5432/rails_test"
      ES_HOST: "http://localhost"
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      # Add or replace dependency steps here
      - name: Install Ruby and gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - name: Install Chrome
        run: sudo apt-get install -y chromium-browser
      # Add or replace database setup steps here
      - name: Set up database schema
        run: rm -f tmp/pids/server.pid && bundle exec rails db:schema:load
      # Add or replace test runners here
      - name: Run tests
        run: rm -f tmp/pids/server.pid && bundle exec rspec

  rubocop:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Install Ruby and gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - name: Lint Ruby files with Rubocop
        run: bundle exec rubocop --parallel

  security:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: Install Ruby and gems
        uses: ruby/setup-ruby@v1
        with:
          bundler-cache: true
      - name: Generate binstubs
        run: bundle binstubs bundler-audit --force
      - name: Security audit dependencies
        run: bundle exec bundler-audit --update
      - name: Security audit application code
        run: bundle exec brakeman -q -w2

  deploy:
    runs-on: ubuntu-latest
    needs: [rspec, rubocop, security]
    if: github.ref == 'refs/heads/main'
    environment: production
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      
      - name: Create GitHub Deployment
        id: deployment
        uses: actions/github-script@v6
        with:
          script: |
            const deployment = await github.rest.repos.createDeployment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: '${{ github.sha }}',
              environment: 'production',
              description: 'Deploying via webhook to ${{ secrets.DEPLOY_TARGET_APP_NAME }}',
              auto_merge: false,
              required_contexts: []
            });
            
            // Set deployment status to in_progress
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: deployment.data.id,
              state: 'in_progress',
              description: 'Deployment started via webhook'
            });
            
            return deployment.data.id;
      
      - name: Trigger Production Deploy
        id: webhook
        env:
          DEPLOY_WEBHOOK_URL: ${{ secrets.DEPLOY_WEBHOOK_URL }}
          DEPLOY_AUTH_HEADER_NAME: ${{ secrets.DEPLOY_AUTH_HEADER_NAME }}
          DEPLOY_AUTH_TOKEN: ${{ secrets.DEPLOY_AUTH_TOKEN }}
          DEPLOY_TARGET_APP_NAME: ${{ secrets.DEPLOY_TARGET_APP_NAME }}
          DEPLOYMENT_ID: ${{ steps.deployment.outputs.result }}
        run: |
          # Create JSON payload for deployment webhook
          PAYLOAD=$(cat <<EOF
          {
            "repository": "${{ github.repository }}",
            "branch": "main",
            "commit_sha": "${{ github.sha }}",
            "commit_message": "${{ github.event.head_commit.message }}",
            "author": "${{ github.actor }}",
            "workflow_run_id": "${{ github.run_id }}",
            "timestamp": "$(date -u +%Y-%m-%dT%H:%M:%SZ)",
            "environment": "production",
            "target_app_name": "$DEPLOY_TARGET_APP_NAME",
            "github_deployment_id": "$DEPLOYMENT_ID"
          }
          EOF
          )
          
          # Send webhook for deployment
          RESPONSE_CODE=$(curl -w "%{http_code}" -s -o /tmp/webhook_response.json -X POST \
            -H "Content-Type: application/json" \
            -H "$DEPLOY_AUTH_HEADER_NAME: $DEPLOY_AUTH_TOKEN" \
            -d "$PAYLOAD" \
            "$DEPLOY_WEBHOOK_URL")
          
          echo "Webhook response code: $RESPONSE_CODE"
          echo "webhook_response_code=$RESPONSE_CODE" >> $GITHUB_OUTPUT
          
          if [ "$RESPONSE_CODE" -ge 200 ] && [ "$RESPONSE_CODE" -lt 300 ]; then
            echo "Webhook triggered successfully"
            echo "webhook_success=true" >> $GITHUB_OUTPUT
          else
            echo "Webhook failed with code $RESPONSE_CODE"
            cat /tmp/webhook_response.json
            echo "webhook_success=false" >> $GITHUB_OUTPUT
            exit 1
          fi
      
      - name: Update Deployment Status - Success
        if: steps.webhook.outputs.webhook_success == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'success',
              description: 'Deployment webhook triggered successfully',
              environment_url: '${{ secrets.DEPLOY_ENVIRONMENT_URL }}'
            });
      
      - name: Update Deployment Status - Failure
        if: failure()
        uses: actions/github-script@v6
        with:
          script: |
            await github.rest.repos.createDeploymentStatus({
              owner: context.repo.owner,
              repo: context.repo.repo,
              deployment_id: ${{ steps.deployment.outputs.result }},
              state: 'failure',
              description: 'Deployment webhook failed'
            });
